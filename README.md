# intern game logic programmer

## Вопрос №1

На языке Python написать алгоритм (функцию) определения четности целого числа,
который будет аналогичен нижеприведенному по функциональности, но отличен по
своей сути. Объяснить плюсы и минусы обеих реализаций.

```python
def isEven(value):
    return value % 2 == 0
```

### Ответ

Весь код в `src/task1.py`.

Аналогичная функция:

```python
def is_even_bitwise(value: int) -> bool:
    return value & 1 == 0
```

Использование операции остатка от деления широко распространено и такая функция
более читабельна. Но использование побитового "И" оказывается производительнее.

Сравнение быстродействия с помощью модуля [timeit](https://docs.python.org/3/library/timeit.html):

Количество итераций: 10 000 000

| Вызов функции              | Время, с |
|----------------------------|---------:|
| `is_even_modulo(100)`      | 0.79395  |
| `is_even_bitwise(100)`     | 0.66929  |
| `is_even_modulo(1000000)`  | 0.73508  |
| `is_even_bitwise(1000000)` | 0.66033  |



## Вопрос №2

На языке Python написать минимум по 2 класса реализовывающих циклический буфер
FIFO. Объяснить плюсы и минусы каждой реализации.

### Ответ

Весь код в `src/task2.py`, `src/ctask2module.c`.


#### Классы `CircularList` ; `CircularBuffer_c`

Буфер использует встроенный тип данных - список, который является динамическим
массивом. Начало и конец - индексы, которые перевычисляются взятием остатка от
деления при каждой операции добавления и удаления элемента.

Класс `CircularBuffer_c` реализован в модуле расширения на языке Си, с
использованием массива.


#### Классы `CircularLinkedListDynamic`*`(_c)`* и `CircularLinkedListStatic`*`(_c)`*

Буфер представляет из себя связный список узлов. Узел - класс `Node`, содержит
данные и ссылку на следующий узел. Начало и конец очереди - ссылки на узлы. При
операциях добавления или удаления элемента эти ссылки обновляются, продвигаясь
циклически дальше по связному списку.

В классе `CircularLinkedListDynamic` узлы создаются во время операции
добавления и стираются во время операции удаления.

В классе `CircularLinkedListStatic` все узлы создаются заранее во время
инициализации, а операции добавления и удаления лишь перезаписывают хранимые в
узлах данные.

Классы с окончанием `_c` реализованы в модуле расширения на языке Си. В них узел
является не классом, а структурой из языка Си, которая хранит указатель на
данные (`PyObject*`) и указатель на следующий узел.


#### Класс `CircularDeque`

Данный класс представляет собой обертку над коллекцией `collections.deque`
(двухсторонней очередью) из стандартной библиотеки. Параметр `maxlen` позволяет
задать длину очереди, при достижении которой, добавление элемента в конец
очереди приводит к отбрасыванию элемента из ее начала, создавая таким образом
циклический буфер. Реализация на Си в [Modules/_collectionsmodule.c](https://github.com/python/cpython/blob/main/Modules/_collectionsmodule.c).


#### Сравнение быстродействия с помощью модуля [timeit](https://docs.python.org/3/library/timeit.html)

Количество итераций: 1 000

Измеряемый сниппет кода:
```python
for i in range(buffer.maxlen):
    buffer.enqueue(i)
for i in range(buffer.maxlen):
    _ = buffer.dequeue()
```

| Класс                         |  Время, с (размер 2<sup>8</sup>) |  Время, с (размер 2<sup>12</sup>) |  Время, с (размер 2<sup>16</sup>) |
|-------------------------------|---------------------------------:|----------------------------------:|----------------------------------:|
| `CircularList`                | 0.08733                          | 1.73087                           | 28.18757                          |
| `CircularLinkedListDynamic`   | 0.12454                          | 2.17078                           | 35.21775                          |
| `CircularLinkedListStatic`    | 0.06302                          | 1.13835                           | 18.50745                          |
| `CircularDeque`               | 0.02271                          | 0.48217                           | 7.94254                           |
| `CircularBuffer_c`            | 0.02134                          | 0.39888                           | 6.63089                           |
| `CircularLinkedListDynamic_c` | 0.02429                          | 0.44149                           | 8.68831                           |
| `CircularLinkedListStatic_c`  | 0.02166                          | 0.39737                           | 6.44734                           |



## Вопрос №3

На языке Python предложить алгоритм, который быстрее всего (по процессорным
тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со
случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы
считаете, что функция соответствует заданным критериям.

### Ответ

Весь код в `src/task3.py`, `src/ctask3module.c`.

Реализация такого алгоритма зависит от сортируемых чисел. Например, когда
известно конечное множество возможных значений сортируемых чисел и их количество
много меньше мощности этого множества, то целесообразно использовать сортировку
подсчетом (функция `counting_sort`*`(_c)`*), у которой временная сложность
составляет &Theta;(n + k), где n - количество элементов массива, а k - мощность
множества их возможных значений.

В качестве решения представлена реализация интроспективной сортировки
(Introsort) - функция `sort`*`(_c)`*.

Алгоритм представляет из себя комбинацию классических сортировок: для
подмассивов маленького размера (не более 20 элементов) применяется сортировка
вставками (Insertion sort). В другом случае применяется Быстрая сортировка
(Quicksort), но при погружении рекурсии более чем на 2log<sub>2</sub>n
применяется Пирамидальная сортировка (Heapsort), для предотвращения ухудшения
времени работы до O(n<sup>2</sup>) при неудачных входных данных.

Функция `builtin` - встроенная сортировка Python (Timsort для версий 2.3 - 3.10
и Powersort для версий 3.11+). Описание содержится в [Objects/listsort.txt](https://github.com/python/cpython/blob/main/Objects/listsort.txt).


#### Сравнение быстродействия с помощью модуля [timeit](https://docs.python.org/3/library/timeit.html)

Количество итераций: 1 000


Массив, содержащий неотсортированные шестнадцатеричные числа:
```python
# [7, 12, 11...]
hexadecimal_digits = [random.randrange(0x0, 0x10) for _ in range(array_size)]
```

| Функция           | Время, с (размер 2<sup>8</sup>) | Время, с (размер 2<sup>12</sup>) | Время, с (размер 2<sup>16</sup>) |
|-------------------|--------------------------------:|---------------------------------:|---------------------------------:|
| `counting_sort`   | 0.02402                         | 0.36748                          | 6.52099                          |
| `counting_sort_c` | 0.00237                         | 0.03317                          | 0.50789                          |
| `builtin`         | 0.00127                         | 0.01612                          | 0.25050                          |
| `sort`            | 0.07855                         | 2.56225                          | 59.84487                         |
| `sort_c`          | 0.02561                         | 0.69030                          | 15.47874                         |


Массив, содержащий неотсортированные числа:
```python
# [0.08834126925343144, 0.9763209982919767, 0.18086510167640257...]
unsorted_array = [random.random() for _ in range(array_size)]
```

| Функция   | Время, с (размер 2<sup>8</sup>) | Время, с (размер 2<sup>12</sup>) | Время, с (размер 2<sup>16</sup>) |
|-----------|--------------------------------:|---------------------------------:|---------------------------------:|
| `builtin` | 0.00103                         | 0.01409                          | 0.24529                          |
| `sort`    | 0.06357                         | 1.81686                          | 44.23251                         |
| `sort_c`  | 0.00593                         | 0.13407                          | 3.33150                          |


Массив, содержащий отсортированные в обратном порядке числа:
```python
# [0.9991060029416422, 0.9982097470309634, 0.9963250254332416]
sorted_array[::-1]
```

| Функция   | Время, с (размер 2<sup>8</sup>) | Время, с (размер 2<sup>12</sup>) | Время, с (размер 2<sup>16</sup>) |
|-----------|--------------------------------:|---------------------------------:|---------------------------------:|
| `builtin` | 0.00104                         | 0.01325                          | 0.23652                          |
| `sort`    | 0.06344                         | 1.82149                          | 42.75726                         |
| `sort_c`  | 0.00591                         | 0.13341                          | 3.18627                          |


Массив, содержащий отсортированные числа:
```python
# [0.00012058646377621773, 0.00012629879167436187, 0.00013528730329082084...]
sorted_array = sorted(unsorted_array)
```

| Функция   | Время, с (размер 2<sup>8</sup>) | Время, с (размер 2<sup>12</sup>) | Время, с (размер 2<sup>16</sup>) |
|-----------|--------------------------------:|---------------------------------:|---------------------------------:|
| `builtin` | 0.00100                         | 0.01312                          | 0.23696                          |
| `sort`    | 0.06466                         | 1.81455                          | 43.44569                         |
| `sort_c`  | 0.00560                         | 0.13432                          | 3.17903                          |
